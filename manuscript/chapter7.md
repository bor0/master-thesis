# 7. Преглед на актуелни текови

Формалната верификација на компјутерските системи датира уште од раните денови на информатиката [10]. Мартин Дејвис во 1954 година го развива првиот компјутерски генериран математички доказ со цел за докажување својства на аритметиката на Пресбургер [29] [30], која беше спомената накратко во 5.2.3.

Двете најактуелни парадигми за програмирање се функционалното програмирање [22] и императивното програмирање [9]. На сличен начин, моделите за формална верификација се темелат врз функционални програми (преку користење на математички типови) [23] и императивни програми (преку користење инваријанти) [9].

Во овој дел од магистерскиот труд ќе бидат разгледани различните модели и актуелните истражувања за формална верификација, како и за виртуелни машини.

## 7.1. Функционално програмирање

Во компјутерската наука, функционалното програмирање е парадигма за програмирање каде што за пресметка се користат функции и композиција на функции. Наместо команди што ја менуваат состојбата на програмата, се користат декларации или математички изрази. Функционалното програмирање се фокусира на опишување што треба една програма да направи, наместо како треба да го направи тоа. Програмските јазици од оваа парадигма најчесто се темелат на **ламбда калкулус** [6] [22].

**Еквивалентноста Кари-Хауард** (исто така позната како Кари-Хауардова кореспонденција или Кари-Хауардов изоморфизам) е директна врска меѓу компјутерските програми и математичките докази. Именувана е според математичарот Хаскел Кари (1900 ‒ 1982) и логичарот Вилијам Хауард (1926). Со други зборови, математички доказ е претставен со компјутерска програма, а формулата што се докажува е **типот** на таа програма [5].

![Пример доказ во Coq\label{coqproof}](images/coqproof.png){ width=600px }

Постојат функционални програмски јазици кои користат типови ‒ такви најпознати се Haskell и Coq ‒ но постојат и такви што не користат типови, на пример Lisp. Во рамките на актуелните истражувања, најкористени се оние со поддршка со типови бидејќи преку нив се вршат математички докази со еквивалентноста на Кари-Хауард.

Најактуелен програмски јазик со поддршка за типови за докажување е Coq [14] [19] [20]. Првата верзија е извадена во 1989 од INRIA, а до ден-денес се користи во индустријата за докази на коректност на софтвер. На пример, може да се искористи за докажување точност на текстуални (линиски) едитори [26], софтверски сервиси [15], a најпознати актуелни докази се CompCert (верификувана имплементација на програмскиот јазик C) [39], union-find податочна структура [40], теоремата на четири бои [41].

Поконкретно, теоремата на четири бои како најактуелна теорема беше докажана во 2005 [41]. Бидејќи самиот доказ на теоремата има многу случаи што треба да се опфатат, дадениот доказ во Coq ја елиминираше потребата од користење на различни компјутерски алатки за секој случај засебно, а притоа доволно е само да му се верува на јадрото на Coq.

Покрај Coq, постојат и други програмски јазици како што се Idris [6] [25] и Agda [27]. Но, за разлика од Coq, овие програмски јазици се сѐ уште во експериментална фаза на истражување ‒ во 2020 излезе нова верзија на Idris 2 која поддржува квантитет на променливи [28].

Едно актуелно истражување во овој дел се однесува на ламбда коцката на слика \ref{lambdacube} како и на различни други особини. На пример, Coq се темели на ламбда калкулус од повисок ред (λC), но Idris 2 се темели на ламбда калкулус со зависни типови (λP). Меѓутоа, покрај основните системи врз кои се темелат, двата програмски јазика имаат различни особини. Како што беше споменато, Idris 2 има особина да назначи квантитет на променливи, додека пак Coq има особина на тактики (апстракција на ламбда изрази). Оттука, иако нивните системи се темелат врз ламбда калкулус, тие сепак се различни бидејќи на еден начин направиле проширување на ламбда калкулус системите.

![Ламбда коцка\label{lambdacube}](images/lambdacube.png){ width=280px }

## 7.2. Императивно програмирање

Во компјутерската наука, императивното програмирање е парадигма за програмирање каде што се користат команди што ја менуваат состојбата на програмата. На ист начин како што императивното однесување на природните јазици изразува команди, императивната програма се состои од команди за компјутерот да ги извршува. Императивното програмирање се фокусира на опишување на тоа како работи дадена програма. Програмските јазици од оваа парадигма најчесто се темелат на **Тјурингови машини** [9].

Како што беше споменато претходно, со користење на **Хоаровата логика** [10] може да се докажуваат математички својства на програми.

Најпознати програмски јазици што поддржуваат енкодирање на Хоарова логика се Java Modeling Language и Dafny, за кој беше дискутирано во шестото поглавје.

Актуелно истражување во овој дел се однесува на SMT solvers ‒ решавачи на задоволителство на формули. Ваквите решавачи се темелат на Constraint Programming ‒ програмирање со ограничувања, каде што ќе биде разгледана минимална имплементација во А.4, а алгоритамот е даден на слика \ref{cp}.

![Програмирање со ограничувања [32]\label{cp}](images/cp.jpeg){ width=500px }

Еден програмски јазик кој претставува SMT solver e Z3, развиен од Microsoft во 2012, а кој се развива до ден-денес [18] и е актуелен и користен во индустријата [31]. Dafny го користи Z3 [11] докажувачот на теореми. Во А.2 ќе биде имплементиран систем кој ќе доволи минимална функционалност на Dafny.

Z3 користи слична синтакса на Lisp и во прилог А ќе биде разгледан краток вовед за него.

Со следниот пример-код се докажува Деморгановото правило, односно $a \land b = \neg (\neg a \lor \neg b)$:

```{language=racket}
(declare-const a Bool)
(declare-const b Bool)
(define-fun demorgan () Bool
    (= (and a b) (not (or (not a) (not b)))))
(assert demorgan)
(check-sat)
```

По извршувањето на овој код, Z3 ќе врати `sat`, што значи дека формулата се задоволува (satisfied). Тоа што е интересно во овој случај е дека беше зададена само формулата што треба да се докаже, а Z3 автоматски го докажа тврдењето.

Dafny е исто така интересен за истражување бидејќи е комбинација од Хоарова логика и Z3, а на тој начин се дозволува автоматско резонирање на предуслови, постуслови и инваријанти од Хоарова логика. Microsoft RiSE (Research in Software Engineering) групацијата врши state-of-the-art[^ch7n1] истражувања, а Z3 и Dafny се нивни производ.

Меѓутоа, мора да се напомене дека е можно да се енкодира императивно програмирање во Coq [19]. Со тоа е овозможено и резонирање на коректност на таквите програми.

## 7.3. Виртуелни машини

Со развитокот на компјутерските технологии, виртуелните машини станаа главна тема на истражување [24]. Виртуелизацијата како таква датира уште од раните 1960-ти, првично развиена од корпорацијата IBM [24].

Општ преглед на архитектурата на овие машини е даден на слика \ref{vmarchitecture}. Во оваа архитектура, повеќе машини ја делат истата физичка машина, а манипулацијата на виртуелните машини се олеснува со тоа што се контролира хардверот преку негова симулација.

![Архитектура на виртуелни машини [24]\label{vmarchitecture}](images/vmarchitecture.png){ width=440px }

Со самото тоа што виртуелните машини се актуелни, пожелно е за нив да се даде математички доказ за коректност за да се осигура дека тие не содржат критични грешки во имплементацијата.

Претходно беше споменато дека формална верификација е скапа задача и бара голем влог. По таа логика, не е ни чудно што нема вложено многу труд во нивната формализација. Можеби еден најпознат таков труд е во [33], но сепак останува поле во кое може да се истражи повеќе.

Темата на овој магистерски труд беше одбрана токму поради оваа причина ‒ неистраженоста на виртуелните машини, заедно со актуелноста на Dafny.

[^ch7n1]: State of the art се однесува на највисоко ниво на општ развој, како на уред, техника или научно поле постигнато во одредено време.
