# 5. Математички основи

Сите инженерски дисциплини вклучуваат одредена употреба на логика. Темелите на програмските јазици се засноваат на систем што имплементира (или кодира) математичка логика. На овој начин може лесно да се "мапира" оваа логика и нејзините правила за заклучување (трансформација) кон компјутерски програми.

Во математиката и компјутерската наука, **Entscheidungsproblem** (германски за "проблем за одлучување") беше предизвик поставен од математичарите Давид Хилберт и Вилхелм Акерман во 1928 година [5]. Проблемот бараше алгоритам кој прима израз како влез и одговара "Да" или "Не" според тоа дали изразот е универзално валиден. Пред да можеше да се одговори на прашањето, поимот **алгоритам** мораше да биде формално дефиниран. Ова го стори математичарот Алонзо Черч (1903 - 1955) во 1935 година со концептот на "ефективна пресметливост" заснована врз **ламбда калкулус** [5]. Истото беше постигнато и од математичарот Алан Тјуринг (1912 - 1954) следната година со неговиот концепт за **Тјурингови машини** [9]. По ова, негативниот одговор на проблемот за одлучување беше даден.

Курт Гедел (1906 - 1978) беше австро-унгарски логичар, математичар и аналитички филозоф. Тој имаше огромен ефект врз научното и филозофско размислување во 20-от век. **Теоремите за некомплетност на Гедел** ги демонстрираат својствените ограничувања на секој формален аксиоматски систем способен за моделирање на основна аритметика. Работата на Черч и на Тјуринг беше под големо влијание и базирана врз претходната работа на Курт Гедел (теоремите за некомплетност), особено со методот на доделување броеви (нумерирање на Гедел) на логички формули со цел да се поедностави логиката на аритметика.

Во ова поглавје ќе бидат разгледани овие концепти подетално.

## 5.1. Формални системи

Пред да може да се конструираат докази за коректност на софтвер, треба да се разбере што е доказ и што значи еден доказ да биде валиден. Целта на формалните системи е да овозможат резонирање за логички докази во однос на нивната _форма_, наместо на нивната _содржина_. Ова ниво на апстракција ги прави формалните системи моќни алатки.

> _Дефиниција 5.1_: **Формален систем** [1, 6] е модел на апстрактно резонирање. Формалниот систем се состои од:
>
> 1. **Формален јазик** што содржи:
>     1. Конечно множество на _симболи_, кое може да се комбинира во конечни стрингови (низа на букви) наречени _формули_
>     1. _Граматика_, што претставува множество на правила кои ни кажуваат кои формули се добро формирани
> 1. Множество на **аксиоми**, односно формули што се прифаќаат како валидни без доказ
> 1. Множество на **правила за заклучување** кои кажуваат како може да се извлечат нови валидни формули од постоечките

Во рамките на даден формален систем, граматиката одредува кои формули се _синтактички_ валидни, додека правилата за заклучување одредуваат кои формули се _семантички_ валидни. Симболите како такви немаат посебно значење, додека правилата за заклучување го дефинираат значењето. Разликата помеѓу овие две е многу важна. На пример, земајќи го македонскиот јазик како (многу комплициран) формален систем, реченицата "Безбојни зелени идеи спијат фуриозно" е синтактички валидна бидејќи различните видови на зборови се користат на соодветните места, но е семантички бесмислена. Откако ќе се дефинира формален систем, други формални системи можат да го прошират. На пример, теоријата на множества се заснова на логика од прв ред, а таа се заснова на исказна логика која претставува формален систем. Понатаму ќе бидат разгледани овие теории.

Во следниот пример ќе биде разгледан "MU" проблемот како формален систем, каде е даден следниот систем:

1. Формален јазик
    1. Множеството на симболи е $\{ M, I, U \}$
    1. Даден стринг е добро формиран ако првата буква е `M` и не постојат други `M` букви. Пример: `M`, `MIUIU`, `MUUUIII`
1. `MI` е почетниот стринг, аксиома
1. Правилата за заклучување се дефинирани на следниот начин:

| Бр. | Правило                | Опис                                     | Пример                             |
| --- | ---------------------- | ---------------------------------------- | ---------------------------------- |
| 1   | x`I` $\to$ x`IU`       | Залепи `U` на стринг кој завршува на `I` | `MI` се трансформира во `MIU`      |
| 2   | `M`x $\to$ M`xx`       | Дуплирај го стрингот после `M`           | `MIU` се трансформира во `MIUIU`   |
| 3   | x`III`y $\to$ x`U`y    | Замени `III` со `U` во стринг            | `MUIIIU` се трансформира во `MUUU` |
| 4   | x`UU`y $\to$ xy        | Тргни `UU` од стринг                     | `MUUU` се трансформира во `MU`     |

  : Пример правила за заклучување

Во правилата за заклучување, симболите `M`, `I` и `U` се дел од системот, додека `x` и `y` се променливи што можат да бидат било која низа симболи (стринг). На пример, врз `MI` може да се примени правило број 2 каде `x = I`, но исто така може да се примени правило број 1 за `x = M`. Така, од `MI` се доаѓа до `MII`, но и до `MIU` соодветно. Друг пример е `MII` на кој може да се примени правило број 2 за `x = II` и правило број 1 за `x = MI`. Во следниот пример ќе се докаже како може да се стигне од `MI` до `MIIU`:

1. `MI` (аксиома)
1. `MII` (правило 2, `x = I`)
1. `MIIII` (правило 2, `x = II`)
1. `MIIIIIIII` (правило 2, `x = IIII`)
1. `MUIIIII` (правило 3, `x = M`, `y = IIIII`)
1. `MUUII` (правило 3, `x = MU`, `y = II`)
1. `MII` (правило 4, `x = M`, `y = II`)
1. `MIIU` (правило 1, `x = MI`)

Се поставува следната задача: дали може да се стигне од `MI` до `MU` во овој систем? За да се докаже ова, ќе биде искористена инваријанта[^ch5n1] заедно со математичка индукција (овие два термини ќе бидат разгледани подетално). За да може да се примени правило број 3, бројот на последователни `I` мора да е делив со 3. Инваријантата се претставува на следниот начин: во даден стринг, не постои низа на `I` со должина делива со 3, а се проверува на следниот начин:

1. За почетната аксиома има едно `I`. Инваријантата поминува
1. Применување на правило 2 ќе го дуплира бројот на `I`, па може да биде: `I`, `II`, `IIII`, `IIIIIII` (генерално, $2^n$ пати `I`). Инваријантата поминува
1. Применување на правило 3 ќе го намали бројот на `I` за 3. Но, $2^n - 3$ не е делив со 3. Инваријантата поминува

На овој начин се покажува дека од почетната аксиома `MI` не е можно да се стигне до `MU` затоа што ниту една низа чекори не може да ја претвори низата со еден `I` во низа без `I`. Но, ако се погледне внимателно, беше искористен различен формален систем за размислување за MU (т.е. деливост на 3, што не е дел од системот MU). Ова е затоа што проблемот не може да се реши во сопствениот систем. Додека во самиот систем, алгоритмот за решавање ќе пробува различни правила за да заклучи `MU`, не знаејќи дека тоа е невозможно [1, 6].

Во секој формален систем постојат бесконечно многу нивоа на изразување: објектно ниво, мета ниво, мета-мета ниво, итн. Во мета нивоата спаѓаат изрази за системот надвор од самиот систем, неограничени од правилата во системот. Објектното ниво е поограничено каде спаѓаат само изрази користејќи ги правилата во самиот систем. На пример, за MU системот мораше да се излезе од системот (мета) за да се реши даден проблем во системот (објект). Ваквото разделување на нивоа (објектно и мета ниво), се објаснува на следниот начин. Под претпоставка дека во даден систем, некоја вредност $A$ може да се замени со $B$, правилото "$A$ може да се замени со $B$" е на мета ниво (на македонски јазик, наместо на јазикот на формалниот систем). Може да се формализира таа мета-реченица во самиот систем, но постојат бесконечно мета нивоа за формализирање, па така не може сите да се опфатат [1, 6].

Подобро е да се размислува за формален систем надвор од системот (на различни мета нивоа), бидејќи нивото на системот може да биде ограничувачко. Како што оди познатата изрека "да се размислува надвор од кутијата". Оттука следува дека е корисно да се има искуство со различни формални системи и да се комбинираат по потреба [6].

## 5.2. Хиерархии на математички логики и дефиниции

На најосновното ниво, математичката логика се занимава со математички концепти изразени со употреба на формални системи. Во овој дел, ќе биде разгледана хиерархијата на овие логички системи. Причината зошто постојат различни нивоа на хиерархии е тоа што на секое ниво, моќта на изразување е поголема. Понатаму, овие логички системи ќе овозможат конструирање математички докази.

### 5.2.1. Исказна логика

Најосновото ниво на логика е исказната логика.

Исказна логика се занимава со изучување на **искази**, кои се реченици што се или вистинити ($\top$), или невистинити ($\bot$) [2, 3, 6]. **Исказни формули** се дефинираат на следниот начин:

1. Логичките константи $\top$ и $\bot$ и исказните букви (променливи) $a, b, \ldots$ се исказни формули
1. Ако $a$ и $b$ се исказни формули, тогаш и $a \land b$ (и), $a \lor b$ (или), $\lnot a$ (негација), $a \to b$ (импикација) и $a \leftrightarrow b$ (еквиваленција) се исказни формули

На пример, може да се каже $a$ : "Салата е органска храна" и со тоа $a$ претставува вистинит исказ. Друг исказ е $a$ : "Камен е органска храна" а со тоа $a$ е невистинит исказ. Реченицата "Здраво!" не е ниту вистинита ниту невистинита и затоа не е исказ.

> _Дефиниција 5.2_: Исказот $a \land b$ (конјункција) е вистинит само кога и **двете** $a$ и $b$ се вистинити.

На пример, исказот "Јас сакам млеко и шеќер" е вистинит само ако "Јас сакам млеко" и "Јас сакам шеќер" се исто така вистинити.

| $\textbf{a}$ | $\textbf{b}$ | $a \land b$ |
| -------------| ------------ | ----------- |
| $\top$       | $\top$       | $\top$      |
| $\top$       | $\bot$       | $\bot$      |
| $\bot$       | $\top$       | $\bot$      |
| $\bot$       | $\bot$       | $\bot$      |

  : Логичко "и"

> _Дефиниција 5.3_: Исказот $a \lor b$ (дисјункција) е вистинит кога **барем едно** од $a$ или $b$ е вистинито.

На пример, исказот "Јас сакам млеко или шеќер" е вистинит само ако барем еден од исказите "Јас сакам млеко" и "Јас сакам шеќер" е исто така вистинит. Ова е познато и како инклузивно "или".

Оваа дефиниција на "или" може да биде малку контраинтуитивна во споредба со тоа како се користи овој збор во секојдневното зборување. За исказот "Јас сакам млеко или шеќер", обично се мисли на едно, но не и на двете. Ова е познато како ексклузивно "или". Но, во рамките на овој труд ќе се користи инклузивно "или".

| $\textbf{a}$ | $\textbf{b}$ | $a \lor b$ |
| ------------ | ------------ | ---------- |
| $\top$       | $\top$       | $\top$     |
| $\top$       | $\bot$       | $\top$     |
| $\bot$       | $\top$       | $\top$     |
| $\bot$       | $\bot$       | $\bot$     |

  : Логичко "или"

> _Дефиниција 5.4_: Негација на исказот $a$ е исказот $\lnot a$ кој има спротивна вистинитост од $a$.

За да се негира некој исказ, доволно е пред него да се додаде "Не е точно дека...". На пример, негацијата на "Ми се допаѓа млеко" е "Не е точно дека ми се допаѓа млеко" или едноставно "Не ми се допаѓа млеко".

| $\textbf{a}$ | $\lnot a$ |
| ------------ | --------- |
| $\top$       | $\bot$    |
| $\bot$       | $\top$    |

  : Логичка негација

> _Дефиниција 5.5_: Импликација на исказите $a$ и $b$ е исказот "Ако $a$ тогаш $b$". Исказот $a \to b$ е точен ако секогаш кога $a$ е точен, исто така и $b$ е точен.

| $\textbf{a}$ | $\textbf{b}$ | $a \to b$ |
| ------------ | ------------ | --------- |
| $\top$       | $\top$       | $\top$    |
| $\top$       | $\bot$       | $\bot$    |
| $\bot$       | $\top$       | $\top$    |
| $\bot$       | $\bot$       | $\top$    |

  : Логичка импликација

Друг начин да се сфати импликација е во смисла на _обврзување_; $a \to b$ претставува обврзување дека ако се случи $a$, тогаш се случува и $b$. На пример, за $a$ : "Денес е твој роденден" и $b$ : "Донесов торта", следува дека $a \to b$ го претставува обврзувањето "Ако денес ти е роденден, тогаш носам торта". Потоа, постојат четири различни начини од кои импликацијата може да добие вредност [6]:

1. "Денес ти е роденден и донесов торта". Ветувањето е задржано, па импликацијата е вистинита
1. "Денес ти е роденден, но не донесов торта". Ветувањето не е задржано, па импликацијата е невистинита
1. "Денес не ти е роденден и донесов торта". Се одржува обврзувањето? Подобро прашање - дали обврзувањето е прекршено? Условот на обврзувањето (дека "денес ти е роденден") не е задоволен, затоа обврзувањето не е прекршено. Импликацијата е вистинита
1. "Денес не ти е роденден и не донесов торта". Повторно, условот на обврзувањето не е задоволен, па така обврзувањето не е прекршено. Импликацијата е вистинита

Оваа дефиниција на импликација може да биде малку контраинтуитивна на начинот на кој се користи во секојдневното зборување. Кога ќе се рече "Ако врне дожд, тогаш земјата е влажна" обично се подразбира и "Ако земјата е влажна, тогаш врне дожд" и "Ако врне дожд, тогаш земјата е влажна". Ова е познато како еквиваленција и се означува со $a \leftrightarrow b$ или $a \ \text{акко} \ b$[^ch5n2].

> _Дефиниција 5.6_: Еквиваленција на исказите $a$ и $b$ е исказот "$a$ ако и само ако $b$". Исказот $a \leftrightarrow b$ е точен секогаш кога $a$ и $b$ имаат иста вистинитост.

| $\textbf{a}$ | $\textbf{b}$ | $a \leftrightarrow b$ |
| ------------ | ------------ | --------------------- |
| $\top$       | $\top$       | $\top$                |
| $\top$       | $\bot$       | $\bot$                |
| $\bot$       | $\top$       | $\bot$                |
| $\bot$       | $\bot$       | $\top$                |

  : Логичка еквиваленција

### 5.2.2. Предикатна логика

Во овој дел ќе биде покажано како може да се прошири исказната логика [6].

> _Дефиниција 5.7_: Предикат е реченица која содржи една или повеќе променливи и која постанува исказ со конкретизација (доделување) вредност на секоја од променливите од некое допустливо множество вредности.

Предикатите ги означуваме со големи букви и наведување на променливите од кои зависи во загради (аргументи). На пример, $P(x)$, $Q(x, y, z)$.

Предикатна логика (логика од прв ред) ја проширува исказната логика со тоа што дополнително дефинира **предикати** и **квантификатори** [2, 3, 6]. Предикат $P(x)$ прима како влез $x$ а како излез дава или вистина или невистина. Постојат два квантификатори: $\forall$ (универзален квантификатор) и $\exists$ (егзистенцијален квантификатор).

Негација на овие квантификатори се дефинира на следниот начин [2]:

1. $\lnot (\forall x, P(x)) \leftrightarrow \exists x, \lnot P(x)$
1. $\lnot (\exists x, P(x)) \leftrightarrow \forall x, \lnot P(x)$

Еден пример на предикат е $P(x)$ : "$x$ е органска храна" каде $P(\text{салата}) = \top$, но $P(\text{камен}) = \bot$.

Во следниот пример, универзалниот квантификатор означува дека предикатот ќе биде вистинит за **сите** можни влезови за $x$: $\forall x, P(x)$. Алтернативно, егзистенцијалниот квантификатор означува дека предикатот ќе биде вистинит за **барем еден** влез за $x$: $\exists x, P(x)$. Друг пример за комбинирање на предикат со универзален квантификатор е $P(x)$ : "$x$ е цицач". Тогаш $\forall x, P(x)$ е вистинит за сите $x$ во множеството на луѓе. Може да се одбере $P(x)$ : "$x$ знае математика" и со $\exists x, P(x)$ да се изрази дека постои барем една личност што знае математика.

\newpage{}

### 5.2.3. Логика од повисок ред

Во логиката од прв ред, предикатите делуваат како функции што земаат влезна вредност и даваат излез. Предикат не може да биде вистинит или невистинит се додека одредена вредност не се примени, додека квантификаторите $\forall$ и $\exists$ "затвораат" даден предикат со тоа што ја одредуваат вистинитоста [6].

На сличен начин, може да се дефинира **мета-предикат** што делува како функција врз предикати. На пример, нека $\Gamma(P)$ го одредува исказот "постои личност $x$ така што $P(x)$ е вистинит". Не може да се одреди вистинитоста на $\Gamma(P)$ се додека не се внесе _специфичен предикат_ $P$. Но, може да се квантифицира преку $P$ со тоа што ќе се конструира реченица, на пр. $\forall P, \Gamma(P)$. На македонски, оваа реченица се преведува во "За било кој предикат (својство) $P$, постои личност која го задоволува тој предикат". Овие мета-предикати припаѓаат во логика од _втор ред_ бидејќи тие квантифицираат предикати од прв ред. На сличен начин може да се дефинираат предикати од трет, четврт, n-ти ред [6].

Логиките од повисок ред ги прошируваат квантификаторите[^ch5n3] врз предикати.

На пример, логика од втор ред квантифицира множества. Логиката од трет ред квантифицира множества од множества (фамилии), итн. Ваквото движење нагоре по хиерархијата на логичките системи носи моќ, за одредена цена. Исказна логика (нулти ред) е комплетно одлучувачка[^ch5n4]. Предикатна логика (прв ред) не е одлучувачка, а од теоремите на некомплетност на Гедел, мора да се одбере едно од комплетност и конзистентност. Но барем, сеуште постои алгоритам што може да одреди дали зададен доказ е валиден или не. За логика од втор (или поголем) ред, се губи и ова својство - мора да се одбере помеѓу комплетност, конзистентност како и алгоритам за детекција на докази.

Во пракса, предикати од втор ред не се користат толку често, а од повисок ред скоро и да се непотребни. Еден значаен пример за предикат од втор ред се појавува во аксиомите на математичарот Џузепе Пеано (1858 - 1932), при дефинирање на природни броеви.

> _Дефиниција 5.8_: **Аксиомите на Пеано** претставуваат формализација на природните броеви. Постојат вкупно 9 аксиоми (збир, производ, неравенки), но ќе бидат набројани само неколку:
>
> 1. $0 \in \mathbb{N}$, односно 0 е природен број
> 1. $\forall x \in \mathbb{N}, S(x) \in \mathbb{N}$, односно за секој природен број $x$ важи дека $S(x)$ е природен број (следбеник функција)
> 1. $\forall x \in \mathbb{N}, x = x$, односно за секој природен број $x$, важи $x = x$ (еднаквоста е рефлексивна)
>
> Деветтата аксиома е аксиомата за индукција, која тврди дека $P(n)$ е вистинит за сите природни броеви под следните услови:
>
> 1. $P(0)$ е вистинит
> 1. За секој природен број $n$ важи дека ако $P(n)$ е вистинит тогаш и $P(n+1)$ е вистинит

Аксиомите на Пеано се изразуваат со употреба на комбинација на логика од прв ред и втор ред. Овој концепт се состои од збир аксиоми за природните броеви и сите тие се искази во логика од прв ред. Исклучок од ова е аксиомата за индукција, која е од втор ред, бидејќи се квантифицира врз предикатите. Овие основни аксиоми можат дополнително да се прошират со аритметички операции на збир, множење, итн.

Аксиомите на Пресбургер се слични со оние на Пеано, каде во овие производот не е вклучен. Поради тоа, за истите постои алгоритам за одлучување, каде во аксиомите на Пеано таков алгоритам не постои. Причината за тоа е дека производ (со прости броеви) е потребно за Геделово нумерирање. Иако производ најчесто се дефинира преку сума (пр. $a \circ b = \underbrace{a + a + \ldots + a}_{\text{b пати}}$), за ова е потребно рекурзија која е невозможна без Геделово нумерирање. Ова ќе биде разгледано подетално во 5.7.

## 5.3. Теорија на множества

Во овој дел ќе биде воведена теоријата на множества, која често се зема за основата на математиката.

> _Дефиниција 5.9_: Теорија на множества е вид на формален систем кој е базиран врз **множества**, што се всушност колекција на објекти [6].

Како и во програмирањето, градењето апстракции во математиката е од еднаква важност. Најдобриот начин да се разбере нешто е да се разберат единките кои го сочинуваат тоа, поединечно. Во следниот дел, теоријата ќе биде објаснета од најниско ниво до врвот - од најосновниот објект (неподредената колекција) па сè до дефинирање на функции.

Множество е **неподредена** колекција на објекти (негови елементи). Овие објекти може да претставуваат било што. Се бележат на начин таков што се пишува листа на објекти во колекцијата, раздвоени со запирка, а затворени во големи загради [6].

На пример, едно множество на овошја е $\{ \text{јаболко}, \text{банана} \}$. Бидејќи ова претставува неподредена колекција, важи дека $\{ \text{јаболко}, \text{банана} \} = \{ \text{банана}, \text{јаболко} \}$.

> _Дефиниција 5.10_: **Членство** на множество претставува кога даден објект припаѓа во некое множество. Се бележи со симболот $\in$ [6].

На пример, $\text{јаболко} \in \{ \text{јаболко}, \text{банана} \}$ означува дека $\text{јаболко}$ припаѓа на тоа множество. Меѓутоа, овој начин на бележење множества не е погоден за големи множества, а невозможен за бесконечни множества. Друг начин е со користење на т.н. _нотација за конструкција на множества_. Во оваа нотација се специфицира множество со задавање на предикат кој ќе биде задоволен од сите елементи. Оваа нотација типично е од формата $\{x \mid P(x)\}$ каде $P$ е предикат. Ако $a$ е специфичен објект, тогаш $a \in \{ x \mid P(x) \}$ е точно кога $P(a)$ е вистинито.

> _Дефиниција 5.11_: **Подредена** $n$-торка е колекција на $n$ објекти во која е воведен "редослед" на елементите од множеството, исто познато како **низа**. Како и множествата, објектите може да бидат било што. Тие се бележат со мали загради, а листата на објекти е раздвоена со запирки [6].

На пример, една таква низа е $(a_1, a_2, ..., a_n)$. Може да се искористи множеството $\{ \{ 1, \{ a_1 \} \}, \{ 2, \{ a_2 \} \}, \ldots, \{ n, \{ a_n \} \} \}$ за да се претстави оваа низа. Ваквото претставување дозволува да се екстрахира $k$-от елемент од $n$-торката (низата) со одбирање на $x$ т.ш. $\{ k, \{ x \} \} \in A$. Оттука важи дека $(a, b) = (c, d) \leftrightarrow a = c \land b = d$, односно дека две двоелементни низи се еквивалентни ако нивниот прв и втор елемент е последователно еднаков. Ова е тоа што ги прави подредени.

Еден пример за низа е $(\text{1 pm}, \text{2 pm}, \text{3 pm})$ која претставува 3 часа во даден ден, секвенцијално.

> _Дефиниција 5.12_: **Декартов производ** се дефинира како множеството $\{ (a, b) \mid a \in A \land b \in B \}$. Се бележи $A \times B$ [2, 6].

На пример, ако $A = \{ a, b \}$ и $B = \{ 1, 2, 3 \}$ тогаш множеството ги претставува следните комбинации: $A \times B = \{ (a, 1), (a, 2), (a, 3), (b, 1), (b, 2), (b, 3) \}$.

> _Дефиниција 5.13_: $A$ е **подмножество** на $B$ ако сите елементи од $A$ се наоѓаат во $B$ (но не мора да значи и обратно). Се бележи $A \subseteq B$ и важи дека $A \subseteq B \leftrightarrow x \in A \to x \in B$ [2, 6].

На пример, изразите $\{ 1, 2 \} \subseteq \{ 1, 2, 3 \}$ и $\{ 1, 2, 3 \} \subseteq \{ 1, 2, 3 \}$ се вистинити. Но овој израз не е вистинит: $\{ 1, 2, 3 \} \subseteq \{ 1, 2 \}$.

Дополнително може да се дефинираат неколку други операции на множества со користење на логичките сврзници:

1. Унија: $A \cup B = \{ x \mid x \in A \lor x \in B\}$
1. Пресек: $A \cap B = \{ x \mid x \in A \land x \in B\}$
1. Разлика: $A \setminus B = \{ x \mid x \in A \land x \notin B\}$

Со следните примери:

1. $\{ 1, 2, 3 \} \cup \{ 1, 2 \} = \{ 1, 2, 3 \}$
1. $\{ 1, 2, 3 \} \cap \{ 1, 2 \} = \{ 1, 2 \}$
1. $\{ 1, 2, 3 \} \setminus \{ 1, 2 \} = \{ 3 \}$

> _Дефиниција 5.14_: **Релација** $R$ се дефинира како подмножество на Декартовиот производ на две множества, односно $R \subseteq A \times B$ [2, 6].

На пример, релацијата "е поголемо од" е бинарна релација (должина 2) за следното множество: $\{ (\text{мачка}, \text{глушец}), (\text{глушец}, \text{сирење}), (\text{мачка}, \text{сирење}) \}$. За вакви бинарни релации важи дека $aRb \leftrightarrow (a, b) \in R$, меѓутоа оваа нотација не е возможна за релации со поголема должина од 2.

> _Дефиниција 5.15_: Функцијата $f$ е бинарна релација[^ch5n5] (2-торка) помеѓу $A$ и $B$ ако на секој елемент од првото множество е назначен точно еден елемент од второто множество. За ваквото мапирање[^ch5n6] важи дека $f \subseteq A \times B$ и се бележи $f : A \to B$.

На пример, функцијата $f(x) = x + 1$ е функција која за даден број, го враќа истиот тој број зголемен за еден. Важи дека $f(1) = 2$, $f(2) = 3$, итн. Друг начин да се претстави оваа функција е со користење на множества: $f = \{ (1, 2), (2, 3), (3, 4), \ldots \}$. Трет начин да се претстават функциите е во форма на табели. Функцијата $f(x)$ која прима некој параметар $x$ се претставува во табела со две колони каде што првата колона е влез, а втората колона е излез. Функцијата $f(x, y)$ која што прифаќа два параметри $x$ и $y$ се претставува со табела со три колони каде што првата и втората колона го претставуваат влезот, а третата колона излезот. Така, функцијата $f(x) = x + 1$ прикажана во форма на табела би изгледала вака:

| $\textbf{x}$ | $f(x)$ |
| ------------ | ------ |
| 1            | 2      |
| 2            | 3      |
| ...          | ...    |

  : Пример на функција

## 5.4. Замена и математички докази

Замената (субституцијата) ја претставува сржта на математиката[^ch5n7], а се состои од систематско заменување на појавувањата на некој симбол со одредена вредност [6]. Може да се примени во различни контексти што вклучуваат формални објекти што содржат симболи.

На пример, ако е дадено следното:

1. Правило на заклучување: Ако $a = b$ и $b = c$, тогаш $a = c$
1. Две аксиоми: $1 = 2$ и $2 = 3$

Тогаш на следниот начин може да се "докаже" дека $1 = 3$:

1. $1 = 2$ (аксиома)
1. $2 = 3$ (аксиома)
1. $1 = 2$ и $2 = 3$ (од 1 и 2 комбинирани)
1. $1 = 3$ (од 3 и правилото за заклучување)

Познато е дека $1 = 3$ нема смисла, но во контекст на даденото погоре, овој доказ е валиден.

> _Дефиниција 5.16_: Во некој израз $P$, променливата $x$ се нарекува **слободна** ако не се појавува во $P$ и не се појавува во некоја од подформулите на $P$. Во спротивно, ако се појавува, тогаш таа се нарекува **врзана** [6].

На пример, $x > 2$ е подформула на изразот $\forall x, x > 2$. Променливата $x$ е врзана во $x > 2$ (од $\forall$). Меѓутоа, во изразот $f(x) = x + y$, $x$ е повторно врзана од $f(x)$, но $y$ е слободна променлива бидејќи таа не се појавува во $f(x)$.

> _Дефиниција 5.17_: **Замена** се бележи со $P[E/x]$, а се дефинира на тој начин што во изразот $P$, секое слободно појавување на $x$ се заменува со $E$ [6].

> _Дефиниција 5.18_: **Математички аргумент** се состои од листа на искази. Математички аргументи се користат со цел да се докаже дека дадено тврдење е точно или неточно [2, 3, 6].

> _Дефиниција 5.19_: **Доказ** е постапка со која се докажува одредено тврдење (исказ). За да се докаже математички факт, треба да се покаже дека заклучокот (целта што се докажува) логично следи од хипотезата (листата на дадени искази) [6].

На пример, за да се докаже дека $G$ следи од множество на искази $\{ g_1, g_2, \ldots, g_n \}$, треба да се покаже дека $(g_1 \land g_2 \land \ldots \land g_n) \to G$. Може да се забележи дека беше искористена импликација во рамките на математички доказ. Постои друг симбол сличен на импликација, симболот $\vdash$ кој има слично значење на импликација, но овој симбол се наоѓа во мета нивото наместо во објектното ниво како импликацијата.

### 5.4.1. Докази преку табели на вистинитости

Се зема следното тврдење како пример: исказот $A \land B \to B$ е вистинит за **било кои вредности** на $A$ и $B$. За да се докаже ова, може да се искористи една техника на докажување - табела на вистинитости. Се претставува на тој начин што даден исказ се разделува во подформули се додека повеќе не може да се раздели (атоми), а секоја подформула од разделувањето се вклучува во колона [2, 3, 6].

| $\textbf{A}$ | $\textbf{B}$ | $A \land B$ |
| ------------ | ------------ | ----------- |
| $\top$       | $\top$       | $\top$      |
| $\top$       | $\bot$       | $\bot$      |
| $\bot$       | $\top$       | $\bot$      |
| $\bot$       | $\bot$       | $\bot$      |

  : Пример доказ со табела на вистинитост

> _Дефиниција 5.20_: Математички аргумент е **валиден** акко секаде каде хипотезата е вистинита, тогаш и заклучокот е вистинит [2, 3, 6].

Во табелата погоре може да се забележи дека секаде каде $A \land B$ е вистинит (листа на искази односно хипотеза), тогаш исто така и заклучокот $B$ е вистинит, што значи дека ова е валиден логички аргумент според дефиниција 5.20.

\newpage{}

### 5.4.2. Три-колонски докази

Друг начин за математичко докажување е со користење на т.н. докази со три колони. За оваа техника се прави табела со три колони: број на чекор, чекор (или израз кој се изведува) и резонирање (објаснување за тоа како е дојдено до одреден чекор) [3, 6].

> _Дефиниција 5.21_: **Модус поненс** (метод на афирмација) и **модус толенс** (метод на негација) се две правила за заклучување во логика. Нивната дефиниција е следна:
>
> 1. Модус поненс: Ако е дадено $p \to q$ и $p$, тогаш може да се заклучи $q$
> 1. Модус толенс: Ако е дадено $p \to q$ и $\lnot q$, тогаш може да се заклучи $\lnot p$

На пример, ако е дадено $A \lor B$, $B \to C$, $\lnot C$, да се докаже $A$. Доказот може да се претстави на следниот начин:

| Бр. | Чекор                      | Резонирање                                                     |
| --- | -------------------------- | -------------------------------------------------------------- |
| 1   | $A \lor B$                 | Дадено                                                         |
| 2   | $B \to C$                  | Дадено                                                         |
| 3   | $\lnot C$                  | Дадено                                                         |
| 4   | $(B \to C) \land \lnot C$  | 2 и 3                                                          |
| 5   | $\lnot B$                  | модус толенс правило на 4, т.е. $(p \to q \land \lnot q) \to \lnot p$ |
| 6   | $(A \lor B) \land \lnot B$ | 1 и 5                                                          |
| 7   | $A$                        | 6, каде $p \land \lnot p$ е контрадикција (невалиден аргумент) |

  : Пример доказ со три-колонски табели

Доказите со табели за вистиности изгледаат многу полесно отколку три-колонските докази. Во табелите за вистиности само се внесува вредности ($\top$ или $\bot$) и се поедноставува, додека три-колонските доказите бараат планирање однапред. Меѓутоа, доказите со табели за вистиности може да се применат само за формули во исказна логика - тие всушност претставуваат алгоритам за одлучување за логика од нулти ред. Затоа тие се полесни, каде три-колонските докази стануваат неопходни во работа каде се вклучени квантификатори [3, 6].

\newpage{}

### 5.4.3. Формални докази

Претходно беше покажано како може да се конструираат докази со табели за вистинитости. Меѓутоа, ако исказите содржат квантификатори, тогаш не е можно да се вршат докази со користење на табели на вистинитости. Споредбено, три-колонските докази содржат премногу детали. Идеално, доказот треба да биде краток, јасен и концизен за тоа што се докажува. Следно, ќе биде докажан одреден исказ формално [2, 3, 6].

За да се докаже $A \land B \to B$, може да се претпостави дека $A \land B$ е вистинит, бидејќи во спротивно, исказот е секако вистинит според дефиниција за импликација. Ако $A \land B$ е вистинито, тогаш и $A$ и $B$ се вистинити, па оттука според дефиниција на $\land$ може да се заклучи и $B$ е вистинит.

За конструирање докази како во претходниот параграф се користат неколку правила. Овие правила одредуваат како може да се искористи хипотезата (дадените информации) и да се постигне заклучокот (целта) на доказот.

За да се **докаже** заклучок од форма [3, 6]:

| Форма на заклучок | Техника                                                |
| ----------------- | ------------------------------------------------------ |
| $P \to Q$ | Се претпоставува дека $P$ е вистинит и се докажува $Q$ |
| $\lnot P$ | Се претпоставува дека $P$ е вистинит и се постигнува контрадикција |
| $P_1 \land P_2 \land \ldots \land P_n$ | Се докажува секое од $P_1, P_2, \ldots, P_n$ посебно |
| $P_1 \lor P_2 \lor \ldots \lor P_n$ | Се користи доказ по случаи, каде во секој случај се докажува едно од $P_1, P_2, \ldots, P_n$ |
| $P \leftrightarrow Q$ | Се докажува $P \to Q$ и $Q \to P$ |
| $\forall x, P(x)$ | Се претпоставува дека $x$ е произволен објект и се докажува $P(x)$ |
| $\exists x, P(x)$ | Се наоѓа $x$ така што $P(x)$ е вистинит |
| $\exists! x, P(x)$[^ch5n8] | Се докажува $\exists x, P(x)$ (егзистенцијалност) и |
| | $\forall x \forall y, (P(x) \land P(y) \to x = y)$ (единственост) |

  : Тактики за докажување заклучоци

\newpage{}

За да се **искористи** дадена хипотеза од форма [3, 6]:

| Форма на хипотеза | Техника                                                |
| ----------------- | ------------------------------------------------------ |
| $P \to Q$ | Ако $P$ е дадено тогаш се заклучува $Q$ (модус поненс) |
| $\lnot P$ | Ако се докаже $P$ тогаш се заклучува контрадикција |
| $P_1 \land P_2 \land \ldots \land P_n$ | Се вклучува секое од $P_1, P_2, \ldots, P_n$ во листата на дадени (хипотеза) |
| $P_1 \lor P_2 \lor \ldots \lor P_n$ | Се користи доказ по случаи, каде во секој случај се претпоставува едно од $P_1, P_2, \ldots, P_n$ |
| $P \leftrightarrow Q$ | Се заклучува $P \to Q$ и $Q \to P$ |
| $\forall x, P(x)$ | За било кое $x$ се заклучува $P(x)$ |
| $\exists x, P(x)$ | Се воведува нова променлива $x_0$ така што $P(x_0)$ е вистинит |
| $\exists! x, P(x)$ | Се воведува нова променлива $x_1$ така што $P(x_1)$ е вистинит и |
| | се докажува $\forall x_1 \forall y, (P(x_1) \land P(y) \to x_1 = y)$ |

  : Тактики за користење хипотези

На пример, овие техники може да се искористат за да се докажат следниве тврдења:

1. $A \land B \to A \lor B$ - За да се заклучи ова, се претпоставува $A \land B$ и се користи доказ по случаи:
    1. Доказ за $A$: Бидејќи е точно дека $A \land B$, исто така е точно и $A$. Оттука, $A$
    1. Доказ за $B$: Бидејќи е точно дека $A \land B$, исто така е точно и $B$. Оттука, $B$
    1. Од точноста на 1 и 2 следува и точноста на $A \lor B$
1. $A \land B \leftrightarrow B \land A$ - За да се заклучи ова ќе се докажат двете страни за импликацијата:
    1. Доказ за $A \land B \to B \land A$: Може да се претпостави $A \land B$, оттука важи $A$ и $B$. За да се заклучи $B \land A$, мора да се докажат $B$ и $A$ посебно, но тие веќе се докажани
    1. Доказ за $B \land A \to A \land B$: Може да се претпостави $B \land A$, оттука важи $B$ и $A$. За да се заклучи $A \land B$, мора да се докажат $A$ и $B$ посебно, но тие веќе се докажани
    1. Оттука, $A \land B \leftrightarrow B \land A$
1. $\forall x, x = x$ - Познато е дека за секој број $x$, тој број е еднаков со самиот себе. Оттука, $\forall x, x = x$
1. $\exists x, x > 0$ - За да се докаже ова, треба да се најде $x$ поголем од 0. Еден таков пример е $x = 1$. Оттука, $\exists x, x > 0$

\newpage{}

### 5.4.4. Математичка индукција

Претходно беше спомената математичка индукција накратко во аксиомите на Пеано. Во овој дел ќе биде дадена точната дефиниција за рекурзивни функции и математичка индукција.

> _Дефиниција 5.22_: **Рекурзивни функции** се функции кои се референцираат (повикуваат) сами на себе [1, 6]. За таквите функции важат следните својства:
>
> 1. Основен случај - терминирачки случај што враќа вредност без да користи рекурзија
> 1. Рекурзивен случај - множество на правила што ги редуцираат случаите кон основниот случај

Еден таков пример за рекурзија е факториел функцијата која се дефинира на следниот начин:

$$ \text{fact}(n) = \left\{ \begin{array}{ll} 1\text{, ако } n = 0 \\ n \cdot \text{fact}(n - 1)\text{, во спротивно} \end{array} \right. $$

На пример, важи дека $\text{fact}(3) = 3 \cdot \text{fact}(2)$, потоа $\text{fact}(2) = 2 \cdot \text{fact}(1)$, потоа $\text{fact}(1) = 1 \cdot \text{fact}(0) = 1$. Оттука следува $\text{fact}(3) = 6$. Иако оваа функција се референцира сама кон себе, другите случаи (освен основниот случај) ги редуцираат изразите кон основниот случај, па таа евентуално ќе терминира.

> _Дефиниција 5.23_: **Математичка индукција** е метода на докажување која се користи за да се докаже некое својство $P(n)$ за сите природни броеви $n$. Слично како и рекурзијата, се содржи од докажување на два дела:
>
> 1. Основен случај - во овој случај треба да се докаже дека $P(k)$ е вистинит за некоја почетна вредност $k$, каде обично $k = 0$
> 1. Индуктивен случај - во овој случај треба да се докаже $P(n) \to P(n+1)$, односно се претпоставува дека $P(n)$ е вистинит и се докажува $P(n+1)$

По докажување на овие два дела, може да се заклучи дека $P(n)$ важи за сите природни броеви. Поконцизно, формулата што треба да се докаже е $P(0) \land ( P(n) \to P(n+1) )$.

За да се разбере како функционира математичката индукција, како пример најдобро е да се визуелизираат домино коцки наредени во низа (Фиг. \ref{dominoes}). Ако се турне првото домино, тоа ќе го турне второто, кое ќе го турне третото и така натаму до бесконечност. Односно, ако се позиционираат домино коцките така што ако некое падне, ќе го турне следното, т.е. од $P(n)$ следи $P(n+1)$, а се турка почетното $P(0)$, тогаш сите домино коцки ќе паднат, т.е. $P(n)$ е целосно вистинито.

![Домино коцки\label{dominoes}](images/dominoes.png){ width=440px }

> _Дефиниција 5.24_: Дадена е следната рекурзивна дефиниција за збир на броеви:
>
> 1. $n + 0 = n$, односно нула е идентитет
> 1. $n + S(m) = S(n + m)$, каде $S$ е следбеник функција, односно $S(0) = 1, S(1) = 2$, итн.

На пример, може да се искористи индукција за да се докаже дека $\forall n, 0 + n = n$ во системот на Пеано. Во овој систем, индукцијата е дадена како аксиома. За основниот случај важи $0 + 0 = 0$ што е точно (според дефиницијата на збир на броеви за $n = 0$). За индуктивниот случај се претпоставува $0 + n = n$ и треба да се докаже дека следи $0 + S(n) = S(n)$. Од дефиниција на збир, важи дека $0 + S(n) = S(0 + n)$ (за замената $n = 0$ и $m = n$). Ако се искористи индуктивната претпоставка тогаш следи дека $0 + S(n) = S(n)$ односно тоа што требаше да се покаже.

## 5.5. Теорија на типови

Како мотивација за потребата на теорија на типови ќе биде претставен **парадоксот на Расел** [3, 6], според математичарот Бертранд Расел (1872 - 1970): Во село во кое има само еден бербер, постои правило според кое берберот ги бричи сите што не се бричат сами и никој друг. Кој го бричи берберот? Ако се претпостави дека берберот се бричи сам себе, тогаш тој е еден од оние што се бричат, но берберот ги бричи само оние што не се бричат, што е контрадикторно. Алтернативно, ако се претпостави дека берберот не се бричи, тогаш тој е во групата луѓе кои берберот ги бричи, што е повторно контрадикторно. Очигледно, тогаш берберот не се бричи, но тој исто така и се бричи - парадокс.

Некои теории на множества се опфатени од парадоксот на Расел. Како одговор на ова, помеѓу 1902 и 1908 година, самиот Бертранд Расел предложува различни теории на типови како обид за решавање на проблемот. Со назначување на **типови** за секоја вредност, парадоксот се избегнува затоа што во оваа теорија секое множество има елементи од посебен тип, на пример, $\text{Тип 1}$. Елементи од $\text{Тип 1}$ можат да бидат вклучени во различно множество, на пример, елементи од $\text{Тип 2}$. Така, парадоксот веќе не е проблем бидејќи множеството на елементи од $\text{Тип 1}$ не може да се содржи во самото тоа множество, бидејќи типовите не се совпаѓаат. На некој начин, се додава хиерархија на множества со цел да се реши проблемот со самореференцијалните множества.

> _Дефиниција 5.25_: **Теорија на типови** е класа на формални системи. Во овие теории, на секој објект се придружува одреден **тип**, а операциите врз овие објекти се ограничени од придружените типови. Со $x : \text{X}$ се означува дека $x$ е од тип $\text{X}$. Функции често се примитивен концепт во овие теории[^ch5n9].

На пример, со $1 : \text{Nat}, 2 : \text{Nat}$ се означува дека 1 и 2 се од тип $\text{Nat}$, односно природни броеви. Друг пример е функцијата $+ : \text{Nat} \to \text{Nat} \to \text{Nat}$ која се интерпретира како функција што прима два објекти од тип $\text{Nat}$ и враќа објект од тип $\text{Nat}$.

> _Дефиниција 5.26_: Во теорија на типови, **типовен конструктор** е функција што конструира нови типови од постоечки, односно прима типови како влез а како излез исто така враќа тип. **Вредносен конструктор** е функција што конструира вредности за дадени типови.

Алгебарските податочни типови се еден вид сложени типови, односно типови конструирани со комбинирање на други типови. Две класи на алгебарски типови се **производ** и **сума**.

> _Дефиниција 5.27_: **Алгебарски податочни типови** се типови што дополнително назначуваат форма на типови на секој од елементите [6]. Тие се нарекуваат "алгебарски" во смисла дека типовите се конструираат со употреба на алгебарски операции. Алгебрата тука е збир и производ:
>
> 1. Сума се означува со $\text{A | B}$ и тоа значи дека конструираната вредност е или од типот A или B
> 1. Производ се означува со $\text{A B}$ и тоа значи дека конструирана вредност е пар каде што првиот елемент е од типот A, а вториот елемент е од типот B

За да се претстави алгебрата што ја сочинуваат, со $|\text{A}|$ се бележи бројот на можни вредности од тип $\text{A}$. Кога се креира алгебарска сума важи дека $|\text{A | B}| = |\text{A}| + |\text{B}|$. Слично, за производ важи $|\text{A B}| = |\text{A}| \cdot |\text{B}|$.

На пример, ако се претпостави дека постојат два типа, $\text{Nat}$ за природни броеви и $\text{Real}$ за реални броеви, тогаш користејќи сума може да се конструира нов тип $\text{Nat | Real}$, за кој некои валидни вредности би биле $1 : \text{Nat | Real}$, $3.14 : \text{Nat | Real}$, итн. Слично, користејќи продукт може да се конструира нов тип $\text{Nat Real}$. Валидни вредности за овој тип се $1 \ 1.5 : \text{Nat Real}$, $2 \ 3.14 : \text{Nat Real}$, итн.

На овој начин, сума и производ може да се комбинираат и да се формираат покомплексни податочни структури.

Друг пример е типот $\text{Bool}$ кој има две можни вредности: $True$ и $False$, односно $|\text{Bool}| = 2$. Типот $\text{Unit}$ (еквивалентно со $()$) има една можна вредност: $Unit$. По ова, може да се формира сума $\text{Bool | Unit}$ со должина 3 со вредностите $True, False, Unit$. Дополнително, производот $\text{Bool Unit}$ има должина 2 со вредности $True \ Unit, False \ Unit$.

## 5.6. Секвентен калкулус

Секвентен калкулус е посебна нотација на математичка логика, особено користена во некои теории, како на пример Хоаровата логика. Секој израз е постигнат (преку правила за заклучување) од претходен израз.

Во следниот израз, хипотезата е $A$ а заклучокот е $B$. Дробната црта претставува импликација (гаранција), односно дека од $A$ следи $B$.

$$ \cfrac{A}{B} $$

Во следниот израз, хипотезата е $A$ и $B$, а заклучокот е $C$. Односно, од $A$ и $B$ следува $C$. Претставено во претходната дискутирана нотација, ова е всушност $A \land B \to C$.

$$ \cfrac{A \quad B}{C} $$

Околина $\Gamma$ се дефинира како листа на искази. Со следниот израз се тврди дека $x$ е од тип $\sigma$ во некоја околина $\Gamma$:

$$ x : \sigma \in \Gamma $$

Во наредниот израз се означува дека дадена околина $\Gamma$ докажува дека $x$ е од тип $\sigma$:

$$ \Gamma \vdash x : \sigma $$

Во наредниот израз се тврди дека некоја околина $\Gamma$ и некое тврдење $x$ од тип $\sigma$ (односно $\Gamma$ е проширена со ова тврдење), докажуваат дека $e_1$ е од тип $\tau$:

$$ \Gamma, x : \sigma \vdash e_1 : \tau $$

Следниот израз означува дека кога $x$ е од тип $\sigma$ во некоја околина $\Gamma$, тогаш $\Gamma$ докажува дека $x$ е од тип $\sigma$.

$$ \cfrac{x : \sigma \in \Gamma}{\Gamma \vdash x : \sigma} $$

## 5.7. Геделови теореми на некомплетност

Програмата на Хилберт беше формулирана од математичарот Давид Хилберт на почетокот на 20-от век [5]. Главната цел на оваа програма беше да се воспостават фондации за целата математика, односно да се дефинира цела математика во формален систем. Со други зборови, програмата бараше да се најде формален систем од кој може да се заклучат **сите** можни вистинити за математика. Во овој дел ќе биде дадена математичкиот одговор на оваа програма.

> _Дефиниција 5.28_: **Геделово нумерирање** е функција која назначува природен број на секој симбол или добро формирана формула во некој формален систем [1, 7, 8].

На пример, во аксиомите на Пеано со дефиниција 5.28 може да се изразат самореферентни искази на објектното ниво во самиот систем на Пеано. Со ова, системот добива моќ на изразување, односно на еден начин, формалниот систем станува "свесен" за сам себе со тоа што може да референцира кон сопствените симболи и формули. Се разгледува следната мапа, каде S е следбеник функцијата:

| Симбол | Број |
| ------ | ---- |
| 0      | 1    |
| 1      | 2    |
| S      | 3    |
| =      | 4    |
| ...    | ...  |
| +      | n    |
| ...    | ...  |

  : Пример на Геделово нумерирање

Во овој случај важи следната еквиваленција, која е формула од системот во самиот систем[^ch5n10]:

$$ 1 = S(0) \equiv (2, 4, 3, 1) \equiv (S(S(0)), S(S(S(S(0)))), S(S(S(0))), S(0)) $$

Како што беше споменато, системот добива во моќ на изразување, но токму оваа моќ е она што ги предизвикува теоремите на некомплетност.

Понатаму се разгледуваат следните 2 реченици:

1. Снег е бела боја
1. Снег има четири букви

Првиот исказ е точен, додека вториот не е точен. Снег како таков нема четири букви (всушност, нема ниту една буква), меѓутоа "Снег" има четири букви. Оваа разлика со наводници е значајна во доказот за Геделовите теореми на некомплетност [7].

> _Дефиниција 5.29_: За некој израз $P$ во кој се појавува променлива $x$, неговата **дијагонализација** $D(P(x))$ е замената на променливата $x$ со целиот израз во наводници [7, 8].

На пример, за изразот $P(x) = \text{Боро чита }x$ дијагонализацијата ќе биде $D(P(x)) = \text{Боро чита "Боро чита }x\text{"}$. Овој начин на претставување овозможува изразување на искази кои се самореферентни. На пример, ако се земат во предвид двете реченици:

1. $P(x)$ - Боро ја чита дијагонализацијата на x
1. $Q(x)$ - Боро ја чита дијагонализацијата на "Боро ја чита дијагонализацијата на x"

Втората реченица изразува дека Боро ја чита дијагонализацијата на првата реченица, односно $Q(x) = D(P(x))$. Но, дијагонализацијата на првата реченица е втората реченица, односно $D(P(x)) = Q(x)$. Всушност, втората реченица се референцира сама себе.

> _Дефиниција 5.30_: Даден формален систем $F$ е [1, 6, 8]:
>
> 1. **Некомплетен** ако има искази што се вистинити, но кои не можат да се докажат како вистинити во $F$
> 1. **Комплетен** ако можат да се докажат сите вистинити искази во $F$
> 1. **Неконзистентен** ако има теорема во тој систем што е контрадикторна
> 1. **Конзистентен** ако нема контрадикторни теореми

\newpage{}

Со Геделово нумерирање, исказот "овој исказ не е докажлив во $F$" може да се претстави во самиот систем $F$, каде со дијагонализација може да се претстави зборот "овој" така што ќе покажува кон истата реченица. Оттука, зададениот исказ може да биде или вистинит или невистинит. Во случај да е вистинит, тогаш не е докажлив во $F$, па оваа вистина не може да се докаже во $F$. Алтернативно, во случај да е невистинит, тогаш е докажлив во $F$, но, не може да се докаже нешто што е невистинито. Така **системот е некомплетен** затоа што некои вистини се недокажливи во него.

> _Теорема 5.31_: Во секој конзистентен формален систем $F$ постојат искази кои не може да се докажат во $F$ [7, 8].

Повторно, со Геделово нумерирање може да се претстави исказот "овој исказ е невистинит во $F$", каде со дијагонализација може да се претстави зборот "овој" така што ќе покажува кон истата реченица. Зададениот исказ е вистинит акко е невистинит и затоа не е ниту вистинит ниту невистинит. **Системот е неконзистентен**.

> _Теорема 5.32_: Даден формален систем $F$ не може да докаже дека самиот е конзистентен во $F$ [7, 8].

Оттука следува дека не постои формален систем[^ch5n11] кој е комплетен и конзистентен. Односно, не постои систем што може да ги содржи сите можни вистини, затоа што даден систем не може да докаже некои вистини за сопствената структура. Курт Гедел го докажува тоа со Геделовите теореми на некомплетност и со тоа го дава одговорот на програмата на Хилберт.

Во принцип, фокусот е честопати на тоа кои делови од математиката можат да се формализираат во конкретни формални системи, наместо да се бара теорија во која може да се развие целата математика [6]. Историски преглед за формализацијата и вистинитоста на математика е даден во [1, 34] каде авторите забележуваат како "не може да се бранат обрасците на расудување засекогаш, во одреден момент вербата превладува".

Сепак, математичките системи иако се несовршени, тие се сепак корисни алатки.

## 5.8. Тјурингови машини

Тјурингова машина претставува апстрактна машина во која општо се опфаќа _пресметувањето_ како поим [9]. Таа се состои од бесконечна лента и конечен број на состојби, а секоја состојба содржи информации за тоа дали лентата ќе се движи лево/десно, што да се запише и која е наредната состојба.

![Тјурингова лента](images/turing-tape.png){ width=450px }

> _Дефиниција 5.33_: **Тјурингова машина** [9] се дефинира преку 7-торката $M = (Q, \Gamma, b, \Sigma, q_{0}, F, d)$ каде:
>
> - $Q$ е непразно множество на состојби
> - $\Gamma$ е непразно множество на симболи на лентата
> - $b$ е празен симбол и важи $b \in \Gamma$
> - $\Sigma$ е множество на влезни симболи кои смеат да се појавуваат во лентата и важи $\Sigma \subseteq \Gamma \setminus \{b\}$
> - $q_{0}$ е почетната состојба, за $q_{0} \in Q$
> - $F$ е множество на конечни прифатливи состојби. Содржината на лентата е прифатена од $M$ ако евентуално стига до некој елемент $f \in F$ и важи $F \subseteq Q$
> - $d : (Q \setminus F) \times \Gamma \to Q \times \Gamma \times \{L,R\}$ е транзициона функција или функција на премин. $L$ претставува лево поместување а $R$ претставува десно поместување. Ако $d$ не е дефинирана во дадена состојба и симбол тогаш машината запира

На пример, машината "зафатен дабар" се претставува на следниот начин:

- $Q=\{{\mbox{A}},{\mbox{B}},{\mbox{C}},{\mbox{HALT}}\}$ - состојби
- $\Gamma =\{0,1\}$ - симболи на лента
- $b=0$ - празниот симбол
- $\Sigma =\{1\}$ - влезни симболи
- $q_{0}={\mbox{A}}$ - почетна состојба
- $F=\{{\mbox{HALT}}\}$ - конечни состојби
- $d$ се дефинира преку табелата подолу

| Симбол | Состојба A | Состојба B | Состојба C   |
| ------ | ---------- | ---------- | ------------ |
| 0      | (1, B, R)  | (1, A, L)  | (1, B, L)    |
| 1      | (1, C, L)  | (1, B, R)  | (1, HALT, R) |

  : Пример на транзициона табела

Како што беше споменато, $d$ е транзициона функција од даден симбол и состојба, во нареден симбол, состојба и поместување на лента. На пример, доколку машината се најде во состојба A со симболот 0, тогаш наредна состојба ќе биде B, ќе се запише симболот 1 и ќе се помести лентата десно. Оваа табела исто така може да се претстави преку дијаграм, како што е покажано на слика \ref{bb-diagram}.

![Дијаграм на зафатен дабар\label{bb-diagram}](images/bb-diagram.png){ width=450px }

Тоа што е заедничко за Тјуринговата машина и императивните програми е што започнуваат со даден влез, преземаат низа чекори што ја менуваат состојбата во меморијата и завршуваат со одреден излез.

> _Дефиниција 5.34_: Било кој формален систем кој може да симулира Тјурингова машина се нарекува **потполно Тјурингов** [9].

На пример, Тјурингови машини се потполно Тјурингови системи, но ламбда калкулус [5] е исто така потполно Тјурингов систем. Исто така, одредена фамилија на рекурзивни функции имаат иста моќ на изразување со Тјурингови машини - оттука истите се потполно Тјурингови.

> _Дефиниција 5.35_: **Проблемот на запирање** (halting problem) претставува проблем кој за даден влез и дадена програма (во потполно Тјурингов систем), одговара дали програмата некогаш ќе заврши или ќе врти бесконечно [9].

Во 1936 Алан Тјуринг докажува дека не постои генерален алгоритам што може да го одговори ова прашање за сите можности, односно за сите парови од типот (влез, програм). Доказот е на следниот начин: се претпоставува дека постои програма $H$ што одредува дали дадена програма $i$ за даден влез $x$ запира или не [9].

$$ H(i,x)={\begin{cases}1&{\text{ако програмата }}i{\text{ запира на влез }}x,\\0{\text{ (запира)}}&{\text{во спротивно}}\end{cases}} $$

Потоа, се претпоставува дека постои програма $H'$ дефинирана на следниот начин:

$$ H'(x)={\begin{cases}{\text{бесконечен циклус}}&H(x,x) = 1,\\0{\text{ (запира)}}&{\text{во спротивно}}\end{cases}} $$

Идејата во ваква дефинираната $H'$ е дека влезот $x$ исто така претставува програм, во делот каде се повикува $H(x,x)$. Следно, пресметката $H'(H')$ ќе прејде во бесконечен циклус ако $H(H', H') = 1$, но, во тој случај следи дека $H'$ запира на $H'$. Значи $H'(H')$ оди во бесконечен циклус и $H'(H')$ запира. Се стига до контрадикција и на тој начин не постои програмата $H$.

Концептите од теоремите за некомплетност на Гедел се од слична природа со оние на проблемот на запирање, имено со самореференцирање.

## 5.9. Хоарова логика

Додека Тјурингова машина претставува имплементација за тоа како една програма работи, Хоарова логика претставува верификација, односно докажува дека дадена програма го прави точно тоа за што е наменета.

> _Дефиниција 5.36_: **Хоарова логика** [10] е формален систем со правила за резонирање на коректност на софтвер.

Хоаровата логика дефинира аксиоми и правила за заклучување за даден едноставен императивен програмски јазик.

> _Дефиниција 5.37_: Централата особина на Хоаровата логика е **Хоаровата тројка** $\{P\}C\{Q\}$ [10] каде:
>
> 1. $P$ е предусловен предикат (предикат кој е вистинит пред да се изврши $C$)
> 1. $C$ е команда
> 1. $Q$ е постусловен предикат (предикат кој е вистинит откако се извршува $C$)

Пример на неколку такви тројки:

- $\{x+1=43\}y:=x+1\{y=43\}$, односно ако $x+1=43$ пред да се изврши $y := x + 1$, тогаш по извршувањето на оваа команда, $y=43$
- $\{x+1\leq N\}x:=x+1\{x\leq N\}$, односно ако $x+1 \leq N$ пред да се изврши зголемување на $x$ за 1, тогаш $x \leq N$ по зголемувањето

Оваа логика претставува моќна алатка за резонирање (докажување својства) на програми. Меѓутоа, во некои случаи каде програмите се нетерминирачки (како што беше покажано со проблемот на запирање), докази за терминирање треба да се покажат посебно.

Во наредната табела ќе бидат наведени правилата од овој систем.

\newpage{}

| Правило     | Формула |
| ----------- | ------- |
| Празно      | $\cfrac{}{\{P\}{\textbf {skip}}\{P\}}$ |
| Доделување  | $\cfrac{}{\{P[E/x]\}x:=E\{P\}}$ |
| Композиција | $\cfrac{\{P\}S\{Q\}\quad \{Q\}T\{R\}}{\{P\}S;T\{R\}}$ |
| Услов       | $\cfrac{\{B\wedge P\}S\{Q\}\quad \{\neg B\wedge P\}T\{Q\}}{\{P\}{\textbf {if}}\ B\ {\textbf {then}}\ S\ {\textbf {else}}\ T\ {\textbf {endif}}\{Q\}}$ |
| Последица   | $\cfrac{P_{1}\rightarrow P_{2}\quad \{P_{2}\}S\{Q_{2}\}\quad Q_{2}\rightarrow Q_{1}}{\{P_{1}\}S\{Q_{1}\}}$ |
| "Додека"[^ch5n12] | $\cfrac{\{P\wedge B\}S\{P\}}{\{P\}{\textbf {while}}\ B\ {\textbf {do}}\ S\ {\textbf {done}}\{\neg B\wedge P\}}$ |

  : Листа на правила од Хоарова логика

На пример, ако е дадено следното (од правилото за доделување):

$$ \{x+1=43\}y:=x+1\{y=43\}, \{y=43\}z:=y\{z=43\} $$

Тогаш според правилото за композиција, може да се заклучи:

$$ \{x+1=43\}y:=x+1;z:=y\{z=43\} $$

На сличен начин, за да се докаже следното:

$$ \{x\leq 10\}{\textbf {while}}\ x<10\ {\textbf {do}}\ x:=x+1\ {\textbf {done}}\{\neg (x<10) \wedge x \leq 10\} $$

Со користење на правилото "додека" прво се докажува:

$$ \{x < 10\}x:=x+1\{x \leq 10\} $$

Што следи од правилото за доделување. Конечно, постусловот $\{\neg (x<10) \wedge x \leq 10\}$ може да се поедностави во $\{x=10\}$.

[^ch5n1]: Инваријанта е својство кое останува непроменето при примена на некое од правилата за трансформација.

[^ch5n2]: Зборот акко е кратенка за "ако и само ако" и значи дека два искази логички се еднакви.

[^ch5n3]: Бидејќи неограничената квантификација доведува до неконзистентност, теоријата на типови е обид да се избегне тоа. Подоцна ќе биде разгледан парадоксот на Расел како пример.

[^ch5n4]: Ова значи дека постои алгоритам за одлучување кој за било кој израз, секогаш ќе врати точна вредност (вистина или невистина), наместо да врти бесконечно или да произведе погрешна вредност.

[^ch5n5]: Во теориите на множества, предикатот $P$ е функција (подмножество на релација), $P \subseteq A \times \{ \top, \bot \}$, каде $A$ е множество на влезови, а излез е или вистина или невистина. Ова може да не е случај со други системи, како на пример логика од прв ред, во која $P(A)$, $P(B)$, итн. се атомски изрази наместо математички функции. Ова е тоа што ја прави логиката од прв ред независна од теорија на множества.

[^ch5n6]: Со други зборови, функција е подмножество на сите комбинации подредени парови чиј прв елемент е од $A$ а втор елемент е од $B$.

[^ch5n7]: Во прилог ќе биде разгледан минимален систем базиран на замена, кој ќе биде доволно моќен да докажува својства.

[^ch5n8]: Нотацијата $\exists!$ значи дека **точно еден** објект го задоволува предикатот.

[^ch5n9]: За разлика од теорија на множества, каде се дефинирани во однос на релации.

[^ch5n10]: Всушност беа искористени низи, но, иако не се дефинирани во Пеано, може да се енкодираат на друг начин. На пример, $(2, 4, 3, 1)$ може да се претстави со бројот $2^2 \cdot 3^4 \cdot 5^3 \cdot 7^1 = 283500$. Постои алгоритам кој од даден број може да ги извади простите множители и така од 283500 да се стигне до $(2, 4, 3, 1)$.

[^ch5n11]: Геделовите теореми ги опфаќаат само оние системи кои овозможуваат изразување аритметика на природни броеви, бидејќи самите теореми зависат од Геделовото нумерирање.

[^ch5n12]: Ова правило претставува инваријанта.
