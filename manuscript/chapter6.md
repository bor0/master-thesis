# 6. Програмирање во Dafny

Dafny е императивен програмски јазик што поддржува формални докази преку предуслови, постуслови и инваријанти [11]. Развиен од Microsoft во 2009, Dafny се користи во академијата и во индустријата и редовно се користи на натпревари за верификација на софтвер.

Како императивен програмски јазик, Dafny дели многу особини со јазици од слична фамилија, како што се C, C++, Java. Постојат функции (методи), променливи, типови, циклуси, условни изрази, низи, броеви, итн.

Dafny претставува автоматски докажувач на математички теореми, но понекогаш е потребно да му се "помогне" за да може да докаже одредена теорема. На пример, Dafny не секогаш знае дека одреден циклус терминира, а ова ќе биде разгледано подетално со командата `decreases`.

На пример, со следниот код се изразува дека секој елемент во дадена низа е позитивен број:

```{language=dafny}
forall k: int :: 0 <= k < a.Length ==> 0 < a[k]
```

Математички, тоа е изразот $\forall k \in a, 0 < k$.

Корисно е да се знаат вакви програмски јазици, бидејќи иако може нема да се користат секојдневно, самата вештина што се добива со нивното изучување нуди критично размислување. Инваријантите, предусловите и постусловите се корисни алатки кога се користи debugger со намера да се реши некоја грешка во програмата. Резонирањето со инваријанти и проверката на претпоставките е една од најбитните карактеристики на еден програмер.

\newpage{}

**Методи и функции**

Методите се налик на математички функции, а се дефинираат на следниот начин:

```{language=dafny}
method Abs(x: int) returns (y: int)
{
    ...
}
```

Со кодот погоре е назначено дека `Abs` е метод што прима `x` од тип `int` (односно цел број) и враќа некое `y` (исто така цел број). Методи може да примаат и да враќаат повеќе од еден параметар, како што е покажано следно:

```{language=dafny}
method MultipleReturns(x: int, y: int) returns (more: int, less: int)
{
    more := x + y;
    less := x - y;
}
```

Во методот `MultipleReturns` едниот вратен параметар ќе претставува збир, а другиот разлика. Доделување на вредност на променлива се врши со симболот `:=`.

Понатаму, функција со име `abs` која прима број и враќа број се дефинира на следниот начин:

```{language=dafny}
function abs(x: int): int
{
    if x < 0 then -x else x
}
```

Разликата меѓу методите и функциите е тоа што функциите (за разлика од методите) може да содржат само еден израз. Исто така, функциите може да се искористат директно во делот на спецификација, за разлика од методите, кои не можат. Функциите не се дел од конечната програма, тие делуваат едноставно како замена на одреден израз (macro).

\newpage{}

**Условни команди**

Условните команди се користат за да се менува текот на програмата, зависно од одредени својства. Во Dafny тие се дефинираат на следниот начин:

```{language=dafny}
method Abs(x: int) returns (y: int)
{
    if x < 0
    {
        return -x;
    }
    else
    {
        return x;
    }
}
```

Вака дефинираната `Abs` кореспондира со следната математичка дефиниција:

$$ Abs(x)={\begin{cases}-x&x < 0,\\x&{\text{во спротивно}}\end{cases}} $$

**Предуслови и постуслови**

Предусловите се дефинираат со додавање на клучниот збор `requires` помеѓу дефиницијата и телото на методот.

```{language=dafny}
method MultipleReturns(x: int, y: int) returns (more: int, less: int)
  requires 0 < y
{
    more := x + y;
    less := x - y;
}
````

Ова кореспондира со Хоаровата тројка:

$$ \{0 < y\}more:=x + y, less := x - y\{{\textbf {true}}\} $$

На следниот начин се дефинираат постусловите:

```{language=dafny}
method Abs(x: int) returns (y: int)
  ensures 0 <= y
{
    if x < 0
    {
        return -x;
    }
    else
    {
        return x;
    }
}
```

Ова кореспондира со Хоаровата тројка:

$$ \{{\textbf {true}}\}x:=Abs(x)\{0\leq x\} $$

Може и двете да се комбинираат заедно:

```{language=dafny}
method MultipleReturns(x: int, y: int) returns (more: int, less: int)
  requires 0 < y
  ensures less < x < more
{
    more := x + y;
    less := x - y;
}
```

Вака напишаниот метод кореспондира со Хоаровата тројка:

$$ \{0 < y\}more:=x + y, less := x - y\{less < x < more\} $$

За докажување на овие тројки може да се искористат правилата од 5.9.

Делот каде се вметнуваат клучните зборови `requires` и `ensures` (помеѓу дефиницијата на функцијата и телото) се нарекува дел на **верификација**, додека делот каде се вметнува кодот (делот помеѓу големите загради) се нарекува дел на **имплементација**.

**Променливи и проверка на тврдења (assertions)**

Променливите се дефинираат со користење на клучниот збор `var`, а потоа врз нив може да се изврши проверка на тврдењата.

На следниот начин се дефинира метод што во телото содржи променлива:

```{language=dafny}
method Testiranje()
{
    var v := Abs(3);
}
```

Во телото на `Testiranje`, вредноста на `v` ќе биде пресметана од претходно дефинираната `Abs`. Со клучниот збор `assert` се потврдува некоја претпоставка:

```{language=dafny}
method Testiranje()
{
    var v := Abs(3);
    assert 0 <= v;
}
```

На овој начин се тврди дека вредноста `v` ќе биде позитивна и Dafny го потврдува тоа. Меѓутоа, ако се напише некое погрешно тврдење:

```{language=dafny}
method Testiranje()
{
    var v := Abs(3);
    assert 0 > v;
}
```

Во овој случај Dafny ќе врати грешка:

```
abs.dfy(4,12): Error: assertion violation
Execution trace:
    (0,0): anon0

Dafny program verifier finished with 1 verified, 1 error
```

**Циклуси и инваријанти**

Циклус претставува една од основните карактеристики во програмирањето. Циклусите всушност повторуваат одредени инструкции додека специфичен услов не биде исполнет.

На следниот начин може да се претстави функцијата што пресметува $\prod\limits_{i = 1}^n x$ односно $x^n$:

```{language=dafny}
function power(x: nat, n: nat): nat
{
    if (n==0) then 1 else x * power(x,n-1)
}
```

Променливите `x` и `n` се од тип `nat`, односно природни броеви. Истиот алгоритам може да се претстави со користење на `while` како во следниот метод:

```{language=dafny}
method Pow(x: nat, n: nat) returns (p: nat)
{
    p := 1;
    var i := n;

    while i != 0
    {
        p := p * x;
        i := i - 1;
    }
}
```

Во овој метод се иницира променлива `i` со вредност `n` и сѐ додека `i` не постигне до 0, се множи со `x`, односно `x*x*...*x` и тоа `n` пати. Овој начин на дефинирање е покомплексен од рекурзивната дефиниција и првично не е очигледно кој алгоритам е претставен. За таа причина, следно ќе се докаже дека `Pow` е еквивалентно со `power`. Тоа се прави со користење на инваријанти во циклусот со клучниот збор `invariant`.

\newpage{}

```{language=dafny}
method Pow(x: nat, n: nat) returns (p: nat)
{
    p := 1;
    var i := n;

    while i != 0
      invariant p == power(x, n-i)
    {
        p := p * x;
        i := i - 1;
    }
}
```

Вака дефинираниот метод означува дека на секоја итерација во циклусот, важи дека `p == power(x, n-i)`. Односно, за `x = 2` и `n = 3` важи:

1. `1 == power(2, 0)`
1. `2 == power(2, 1)`
1. `4 == power(2, 2)`
1. `8 == power(2, 3)`

Со ова, може да се додаде кодот `ensures p == power(x, n)` во делот на верификација на методот `Pow`, меѓутоа мора да се забележи дека овој код е зависен од инваријантата што беше вметната во циклусот. Доколку таа инваријанта не постои, Dafny нема да може автоматски да го потврди тврдењето. Со инваријантата на еден начин му се помага на Dafny да го докаже тврдењето на тој начин што се "пополнуваат" одредени делови што недостасуваат за да може да се изврши автоматското тврдење.

\newpage{}

**Терминација**

Со следниот код се претставува циклус за `i` од 0 до `n`:

```{language=dafny}
method Ciklus()
{
    var i := 0;
    var n := 20;
    while i != n
    {
        i := i + 1;
    }
}
```

Во овој случај, Dafny ќе ја врати следната грешка:

```
ciklus.dfy(5,4): Error: cannot prove termination; try supplying a decreases clause for the loop
```

Циклусите `while` претставуваат проблем за Dafny. Не постои начин Dafny автоматски да знае колкупати ќе се изврши даден циклус (според проблемот на запирање). Со користење на клучниот збор `decreases` треба да му се покаже на Dafny дека одреден израз се намалува. Односно, ако `n - i` се намалува, тогаш овој циклус евентуално ќе запре, бидејќи врти сѐ додека `i != n`.

```{language=dafny}
    while i != n
      invariant 0 <= i <= n
      decreases n - i
    {
        i := i + 1;
    }
```

Дополнително беше назначено дека `i` е ограничена, бидејќи во спротивно Dafny ќе вратеше грешка:

```
ciklus.dfy(6,20): Error: decreases expression must be bounded below by 0 at end of loop iteration
```

\newpage{}

**Низи и квантификатори**

Низите се дефинираат со клучниот збор `array<...>` каде што `...` е одреден тип. До специфични елементи на низа се пристапува со синтаксата `x[i]`, односно `i`-от индекс во низата `x`. На пример, со следниот код се дефинира метод што ќе го најде најголемиот број во дадена низа:

```{language=dafny}
method FindMax(a: array<int>) returns (max: int)
  requires 0 < a.Length
{
    var index := 0;
    max := a[0]; // pretpostavka deka prviot e najgolem
    while index < a.Length
    {
        if a[index] >= max
        {
            max := a[index];
        }
        index := index + 1;
    }
}
```

Во кодот погоре се искористи `requires` за должината на низата, бидејќи во спротивно ќе се добиеше грешка `Error: index out of range`.

Со следниот пример ќе се покаже како може да се искористат квантификатори, со тоа што ќе се докаже дека постои најголем елемент во која било низа, односно следното својство:

$$ \exists m \forall k \in a, k \leq m $$

За таа цел ќе бидат искористени клучните зборови `forall` и `exists`, кои кореспондираат со логиката во 5.2.2.

\newpage{}

Дефиницијата на методот се менува на следниот начин:

```{language=dafny}
method FindMax(a: array<int>) returns (max: int)
  requires 0 < a.Length
  ensures exists k :: 0 < k < a.Length ==> max == a[k]
  ensures forall k :: 0 < k < a.Length ==> max >= a[k]
{
    var index := 0;
    max := a[0]; // pretpostavka deka prviot e najgolem
    while index < a.Length
    {
        if a[index] >= max
        {
            max := a[index];
        }
        index := index + 1;
    }
}
```

Двата квантификатора се поделени во два различни израза. Првиот израз означува дека постои таков максимален елемент, а вториот израз означува дека сите елементи во низата се помали или еднакви на тој елемент. Но, доколку се изврши дадениот код, ќе се добие следната грешка:

```
test.dfy(8,4): Error BP5003: A postcondition might not hold on this return path.
test.dfy(4,12): Related location: This is the postcondition that might not hold.
test.dfy(4,49): Related location
```

Односно, линија 4 не може да се докаже поради линија 8.

Слично како и претходно, доколку му се помогне на Dafny со тоа што ќе се внесат точните инваријанти во циклусот, Dafny ќе може успешно да го докаже тврдењето.

\newpage{}

Комплетниот метод е претставен на следниот начин:

```{language=dafny}
method FindMax(a: array<int>) returns (max: int)
  requires 0 < a.Length
  ensures exists k :: 0 < k < a.Length ==> max == a[k]
  ensures forall k :: 0 < k < a.Length ==> max >= a[k]
{
    var index := 0;
    max := a[0]; // assume first is max
    while index < a.Length
      invariant 0 <= index <= a.Length
      invariant forall k :: 0 <= k < index ==> max >= a[k]
    {
        if a[index] >= max
        {
            max := a[index];
        }
        index := index + 1;
    }
}
```

\newpage{}

**Индукција и леми**

Со следниот код се претставуваат два метода со кои едниот пресметува $\sum\limits_{i=0}^n i$ а другиот $\frac{n \cdot (n+1)}{2}$.

```{language=dafny}
function method sum(n: nat): nat
  decreases n
{
    if n == 0 then 0 else n + sum(n-1)
}

function method sum_2(n: nat): nat
{
    n * (n+1)/2
}
```

Како пример, може да се докаже дека овие две функции се еквивалентни. Тоа може да се постигне со користење на командата `assert`.

```{language=dafny}
method Main()
{
    assert forall n :: 0 <= n ==> sum(n) == sum_2(n);
}
```

Методот `Main` го претставува првиот метод што ќе се пресмета при извршување на програмата.

Во овој случај се добива грешка од Dafny бидејќи треба да се искористи индукција врз `n`. Проблемот се решава со следниот код:

```{language=dafny}
lemma {:induction n} sum_lemma(n: nat)
  ensures sum(n) == sum_2(n)
  {}
```

На овој начин се користи лема со индукција, каде што телото на лемата е празно бидејќи Dafny автоматски го докажува тврдењето.

\newpage{}

**Податочни типови и совпаѓање на шеми**

Иако Dafny се темели на Хоарова логика, сепак вклучува некои својства од теоријата на типови. Едно такво својство е дефинирање на нови алгебарски податочни типови.

> _Дефиниција 6.1_: Структура на **бинарно дрво** е начин за хиерархиско претставување на податоците. Се дефинира со двата вредносни конструктора:
>
> 1. `List`, без дополнителни вредности
> 1. `Jazol`, односно јазол кој содржи природен број и уште две други вредности од тип `Drvo`

Односно, се претставува со следниот псевдокод:

```
Drvo ::= List | Jazol Nat Drvo Drvo
```

На пример, изразот `Jazol 2 (Jazol 1 List List) (Jazol 3 List List)` го претставува следното дрво:

```
  2
 / \
1   3
```

За дефинирање типови во Dafny, се користи клучниот збор `datatype`, како во следниот пример:

```{language=dafny}
datatype Drvo<T> = List | Jazol(T, Drvo, Drvo)
```

Со ова се создава нов типовен конструктор `Drvo T` (може да биде `Drvo int`, `Drvo nat`, итн.) со конструктори за вредности `List` и `Jazol`. `List` е конструктор кој не прима параметри, но `Jazol` е конструктор кој прима три параметри: вредност `T` (`int`, `nat`, итн.), дрво (лево) и уште едно дрво (десно). Оваа дефиниција кореспондира со дефиниција 6.1.

\newpage{}

Совпаѓање на шеми (pattern-match) е друг значаен концепт, особено во делот на рекурзивни податочни типови како што е `Drvo`.

```{language=dafny}
match(t)
{
    case Empty => ...
    case Jazol(x, lev, desen) => ...
    ...
}
```

Ова е, всушност, поедноставена верзија на `if-else`, каде што одреден израз се совпаѓа (match-ува) со одредени вредности. Доколку се совпадне вредноста, се враќа тој случај.

За пример може да се земе функција што ќе провери дали даден елемент се содржи во дрво на следниот начин:

```{language=dafny}
function Sodrzi<T>(t: Drvo, v: T): bool
{
    match t
    {
        case List => false
        case Jazol(x, lev, desen) =>
            if x == v then true else
                if Sodrzi(lev, v) then true else
                    if Sodrzi(desen, v) then true else false
    }
}
```

Функцијата рекурзивно ќе прошета околу дадено `Drvo`, а елементот `v` ќе се содржи во тоа дрво само ако `x == v` за која било вредност `x` во дрвото.

\newpage{}

**Класи**

Понекогаш е потребно да се групираат одредени променливи и функции/методи. Од објектно-ориентирано програмирање, тоа се постигнува со класи, а во Dafny со користење на клучниот збор `class`.

Со следниот код се дефинира класа која со користење на клучниот збор `constructor` дефинира конструктор што е всушност функција што се извршува при иницијализација на класата. Типовите `bv8` и `bv16` се вградени во Dafny и служат за работа со битови. Доколку не постоеја, ќе беше потребно да се создаде нов тип, со користење на клучниот збор `datatype`.

```{language=dafny}
class VM
{
    var v: array<bv8>;
    var I: bv16;

    constructor ()
      ensures I == 123
    {
        I := 123;
    }
}
```

Потоа, со креирање инстанца од класата, вредноста на `I` ќе изнесува 123. Односно следниот код ќе испечати 123.

```{language=dafny}
method Main()
{
    var vm := new VM();
    print vm.I;
}
```

\newpage{}

Покрај конструктори, може да се дефинираат и предикати со користење на клучниот збор `predicate`. Тоа се налик функции, а се корисни кога некој код треба да се употреби неколкупати. Дополнително треба да се специфицира `reads this` за да му се каже на Dafny дека овој предикат ќе ја чита тековната инстанца од класата.

```{language=dafny}
class VM
{
    var v: array<bv8>;
    var I: bv16;

    predicate Valid()
      reads this
    {
        I == 123
    }

    constructor ()
      ensures Valid()
    {
        I := 123;
    }
}
```

Доколку класата е напишана на овој начин, тогаш други методи/функции надвор од неа може да повикаат `requires vm.Valid()` за да се осигура дека својствата од конструкторот ќе бидат исполнети.

## 6.1. Пример: Докажување на својство за $\min$

Со следниот пример ќе се докаже математичкото својство:

$$ \min(a - c, b - c) = \min(a, b) - c $$

Функцијата $\min$ се дефинира математички на следниот начин:

$$ \min(a, b) = {\begin{cases}a&{\text{ако }} a < b,\\b&{\text{во спротивно}}\end{cases}} $$

Во Dafny се дефинира на следниот начин:

```{language=dafny}
function min(a: int, b: int): int
{
    if a < b then a else b
}
```

По дефинирањето на функцијата, следува доказот. Тој е едноставно:

```{language=dafny}
method m()
{
    assert forall a, b, c :: min(a - c, b - c) == min(a, b) - c;
}
```

Се добива следната порака од Dafny:

```
Dafny program verifier finished with 3 verified, 0 errors
Program compiled successfully
```

Со тоа, доказот е завршен. За да се докаже тоа математички, се користи доказ по случаи:

1. Случај $a - c > b - c$: Важи дека $\min(a - c, b - c) = b - c$, а од $a - c > b - c$ следува $a > b$ односно $\min(a, b) = b$. Значи $b - c = b - c$ и случајот е докажан
2. Случај $a - c \le b - c$: Важи дека $\min(a - c, b - c) = a - c$, а од $a - c < b - c$ следува $a < b$ односно $\min(a, b) = a$. Значи $a - c = a - c$ и случајот е докажан

Со овие два случаја, може да се заклучи дека $\min(a - c, b - c) = \min(a, b) - c$.

\newpage{}

## 6.2. Пример: Парцијален ред

Во овој дел ќе биде претставена дефиницијата на алгебарската структура парцијален ред како пример имплементација во Dafny [12]. Потоа, ќе се докаже дека природните броеви со операцијата $\leq$ претставуваат парцијален ред.

> _Дефиниција 6.2_: Бинарна релација $R$ на некое множество $S$ е парцијален ред ако важат следните својства:
>
> 1. $\forall a \in S, a R a$, односно рефлексивност
> 1. $\forall a, b, c \in S, a R b \land b R c \to a R c$, односно транзитивност
> 1. $\forall a, b \in S, a R b \land b R a \to a = b$, односно антисиметричност

Се претставува со следниот код во Dafny:

```{language=dafny}
predicate method order(a: nat, b: nat)
{
    a <= b
}

lemma reflexive()
  ensures forall a :: order(a, a)
{}

lemma transitive()
  ensures forall a, b, c :: order(a, b) && order(b, c) ==> order(a, c)
{}

lemma total()
  ensures forall a, b :: order(a, b) && order(b, a) ==> a == b
{}
```

Dafny автоматски докажува дека лемите ја задоволуваат дефиницијата на `order` $(\mathbb{N}, \leq)$. Но, доколку, на пример, $(\mathbb{N}, \leq)$ се смени во $(\mathbb{N}, <)$, тогаш Dafny ќе јави грешка бидејќи рефлексивноста нема да биде исполнета.

## 6.3. Пример: Рачен и автоматски доказ на идентитет на броеви

Бидејќи Dafny е автоматски докажувач, некои математички тврдења може да се докажат автоматски, без притоа да се даде аргументот за нив. Но, истите тие може да се докажат и рачно, како што ќе биде покажано.

Доказот за следниот пример ќе биде со индукција, каде што се користи клучниот збор `match` за започнување на индукцијата и клучниот збор `calc` (за секој случај од индукцијата) во кој се внесуваат искази што тврдат некое својство. Следниот доказ е налик на доказот во 5.4.4 за дефиницијата 5.23.

```{language=dafny}
lemma {:induction n} lev_identitet(n: Nat)
  decreases n;
  ensures plus(Z, n) == n
{
    match n {
        case Z =>
            calc == {
                plus(Z, Z); ==    // 0 + 0
                Z;                // 0
            }
        case S(z) =>
            calc == {
                plus(Z, n); ==    // 0 + n
                S(plus(Z, z)); == // S(0 + z)
                S(z);             // S(z)
            }
    }
}
```

Каде што природните броеви се дефинирани на следниот начин:

```{language=dafny}
datatype Nat = Z | S (Nat)
```

Заедно со операцијата за собирање, која е налик на дефиницијата 5.23:

```{language=dafny}
function plus(x: Nat, y: Nat) : Nat
  decreases x;
{
    match x {
        case Z    => y
        case S(z) => S(plus(z, y))
    }
}
```

По доказот погоре може да се забележи дека со користење на `calc` се започнува од левата страна на еднаквоста, а во секој нареден чекор постепено се стигнува до крајниот резултат од десната страна на еднаквоста. Овој систем за докажување е налик на триколонските докази како што беа прикажани во 5.4.2.

Но, истиот доказ може и автоматски да се постигне на следниот начин:

```{language=dafny}
lemma lev_identitet_2(n: nat)
  ensures 0 + n == n
{}
```

Dafny успеа автоматски да го докаже тврдењето, но не секогаш успева да го прави тоа. Во тој случај, рачните докази може да бидат корисни.

Рачните докази се темелат на структурирани калкулациски докази [4]. Поконкретно, Dafny го користи следното правило на заклучување:

$$ \cfrac{\Gamma_1 \vdash A \equiv B \quad \Gamma_2 \vdash B \equiv C}{\Gamma_1 \cup \Gamma_2 \vdash A \equiv C} $$

Односно, доколку во некои околини (листи на искази) важи дека $A \equiv B$ и $B \equiv C$, тогаш може да се заклучи дека $A \equiv C$ [^ch6n1]. Доколку некоја од формулите не се совпаѓа со претходната или со следната, Dafny ќе врати грешка.

[^ch6n1]: Оваа формула е претставена во мета-ниво. Таа може да се претстави во објектно ниво како $a \to b \land b \to c \implies a \to c$.
